package com.kartik.org;



/**
 * Rotate Linked List block wise
Given a Linked List of length n and block length k rotate in circular manner towards right/left each block by a number d. If d is positive rotate towards right else rotate towards left.

Examples:

Input: 1->2->3->4->5->6->7->8->9->NULL, 
        k = 3 
        d = 1
Output: 3->1->2->6->4->5->9->7->8->NULL
Explanation: Here blocks of size 3 are
rotated towards right(as d is positive) 
by 1.
 
Input: 1->2->3->4->5->6->7->8->9->10->
               11->12->13->14->15->NULL, 
        k = 4 
        d = -1
Output: 2->3->4->1->6->7->8->5->10->11
             ->12->9->14->15->13->NULL
Explanation: Here, at the end of linked 
list, remaining nodes are less than k, i.e.
only three nodes are left while k is 4. 
Rotate those 3 nodes also by d.
 
 @link http://www.interviewdruid.com/category/linked-lists/
 * @author kmandal
 *
 */
public class LinkListRotatedByBlockWise {

	static Node head;

	private static class Node {
		private int data;
		private Node next;

		Node(int data) {
			this.data = data;

		}
	}

	public void addToTheLast(Node node) {

		if (head == null) {
			head = node;
		} else {
			Node temp = head;
			while (temp.next != null)
				temp = temp.next;

			temp.next = node;
		}
	}


	public void printList(Node head) {
		Node temp = head;
		while (temp != null) {
			System.out.format("%d ", temp.data);
			temp = temp.next;
		}
		System.out.println();
	}

	// For printing Linked List
	public static void printLinkedList() {
		System.out.println("Printing LinkedList (head --> last) ");
		Node current = head;
		while (current != null) {
			System.out.println(current.data + "");
			current = current.next;
		}
		System.out.println();
	}

	
	// Recursive function to rotate one block 
	static Node rotateHelper(Node blockHead, Node blockTail, int d, Node tail,
			int k)
	{ 
	    if (d == 0) 
	        return blockHead; 
	  
	    // Rotate Clockwise 
	    if (d > 0) { 
	        Node temp = blockHead; 
	        for (int i = 1; i < k - 1; i++) 
	            temp = temp.next; 
	        blockTail.next = blockHead; 
	        tail.next = temp; 
	        return rotateHelper(blockTail, temp, 
	                            d - 1, tail, k); 
	    } 
	  
	    // Rotate anti-Clockwise 
	    if (d < 0) { 
	        blockTail.next = blockHead; 
	        tail.next = blockHead; 
	        return rotateHelper(blockHead.next, 
	                blockHead, d + 1, tail, k); 
	    }
		return tail; 
	} 
	  
	// Function to rotate the linked list block wise 
	static Node rotateByBlocks(Node head, 
	                                 int k, int d) 
	{ 
	    // If length is 0 or 1 return head 
	    if (head==null || head.next==null) 
	        return head; 
	  
	    // if degree of rotation is 0, return head 
	    if (d == 0) 
	        return head; 
	  
	     Node temp = head, tail = null; 
	  
	    // Traverse upto last element of this block 
	    int i; 
	    for (i = 1; i < k; i++) 
	        temp = temp.next; 
	  
	    // storing the first node of next block 
	     Node nextBlock = temp.next; 
	  
	    // If nodes of this block are less than k. 
	    // Rotate this block also 
	    if (i < k) 
	        head = rotateHelper(head, temp, d % k, tail, i); 
	    else
	        head = rotateHelper(head, temp, d % k, tail, k); 
	  
	    // Append the new head of next block to 
	    // the tail of this block 
		//tail.next = rotateByBlocks(nextBlock, k, d % k); 
	  
	    // return head of updated Linked List 
	    return head; 
	} 
	
	
	static  Node reverse(Node head, int k) 
	    { 
	       Node current = head; 
	       Node next = null; 
	       Node prev = null; 
	         
	       int count = 0; 
	  
	       /* Reverse first k nodes of linked list */
	       while (count < k && current != null)  
	       { 
	           next = current.next; 
	           current.next = prev; 
	           prev = current; 
	           current = next; 
	           count++; 
	       } 
	  
	       /* next is now a pointer to (k+1)th node  
	          Recursively call for the list starting from current. 
	          And make rest of the list as next of first node */
	       if (next != null)  
	          head.next = reverse(next, k); 
	  
	       // prev is now head of input list 
	       return prev;
	    }

	public static void main(String[] args) {
		LinkListRotatedByBlockWise list=new LinkListRotatedByBlockWise();
		// Creating a linked list
		Node head=new Node(5);
		list.addToTheLast(head);
		list.addToTheLast(new Node(6));
		list.addToTheLast(new Node(7));
		list.addToTheLast(new Node(1));
		list.addToTheLast(new Node(2));

		list.printList(head);
	}
}
